public class JvmComprehension {
    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }
    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
//Описание работы программы:
1)Когда встречается новый класс JvmComprehension (далее просто класс), 
то он отдаётся для загрузки в систему загрузчиков классов (ClassLoaders)
и ищется последовательно в:
Bootstrap ClassLoader-> Platform ClassLoader-> Application ClassLoader.
Как только какой-то из ClassLoaders находит искомый класс, то поиск прекращается, 
и происходит загрузка данных о классе и его констант в область памяти Metaspace. 
Последним ищет класс пользовательский ClassLoader, если он есть.
Если класс не найден, то выбрасывается исключение java.lang.ClassNotFoundException.

2)Потом происходит связывание в 3 этапа: проверка валидности кода,
подготовка примитовов в статических полях и разрешение ссылок на другие классы.

3)Далее выполняется инициализация класса - выполняются static-инициализаторы и 
инициализация static-полей, если таковые имеются (в нашем случае их нет).

4)В момент вызова метода main создаётся фрейм в области памяти Stack Memory(стек).
В метод main передётся ссылка на массив объектов класса String(args).

строка 1: в стеке выделяется память для переменной i и присваивается значение 1. 

строка 2: в куче(heap) создаётся объект класса Object, 
далее в стеке во фрейме main выделяется память для переменной o, 
хранящий адрес созданного объекта класса Object.

строка 3: в куче создаётся объект класса Integer, 
далее в стеке во фрейме main выделяется память для переменной ii и присваивается значение 2.

строка 4: в стеке создаётся фрейм для фукнции printAll. 
В функцию передаются переменные: o, i и ii.

строка 5: в куче создаётся объект класса Integer, хранящий значение 700.
далее в стеке во фрейме printAll выделяется память для переменной uselessVar, 
хранящий адрес созданного объекта класса Integer.

строка 6: 
- в стеке создаётся фрейм для функции toString, в куче создаётся объект класса String(будем называет его str),
 равный о.toString(), 
 
- в куче создаётся объект класса StringBuilder (обозначим его s) на основе строки str,
вызывается метод append и потом toString: s = new StringBuilder(str).append(i).toString(),

- в куче создаётся объект класса StringBuilder (обозначим его s2) на основе строки str,
вызывается метод append и потом toString: s2 = new StringBuilder(s).append(ii).toString().

- в стеке создаётся фрейм для фукнции System.out.println

- адрес строки s2 передаётся на вход функции System.out.println.

- при выходе из функции printAll удаляется фрейм с переменной uselessVar, ссылающейся на объект класса Integer.
Больше ссылок на этот объект не остаётся, поэтому достучаться до этого объекта из остальной части программы никак нельзя.
При ближайшем вызове сборщика мусора этот объект будет удалён, если проведены была только одна сборка или их вовсе ещё не было.
Также обстоят дела с ссылками на строки, обозначенные нами как str, s и s2.

строка 7: 
- в стеке создаётся фрейм для фукнции System.out.println

- в куче создаётся объект класса String, содержащий строку "finished",
 и ссылка на этот объект передаётся на вход функции System.out.println.
 
 - После завершения метода main удалятся все оставшиеся объекты и переменные:
 i, o, ii, "finished".